#!/bin/sh
# -*- python -*-
#
# Copyright 2013-2024 Lawrence Livermore National Security, LLC and other
# Spack Project Developers. See the top-level COPYRIGHT file for details.
#
# SPDX-License-Identifier: (Apache-2.0 OR MIT)

# This file is bilingual. The following shell code finds our preferred python.
# Following line is a shell no-op, and starts a multi-line Python comment.
# See https://stackoverflow.com/a/47886254
""":"
# prefer SPACK_PYTHON environment variable if set.
if test ! -z "$SPACK_PYTHON"; then
    if command -v "$SPACK_PYTHON" > /dev/null; then
        export SPACK_PYTHON=`command -v "$cmd"`
        exec "${SPACK_PYTHON}" "$0" "$@"
    fi
fi
# We now must try to find a python in the path that is not one that Spack
# itself has installed. Spack installed pythons can be elliminated by looking
# if the parent directory of sys.prefix is '._view' while
# sys.prefix != sys.base_prefix (from a python virtual environment).
#
# For the prefered pythons, we will first try each one till we find one
# suitable. If none are found, we will use which or whereis on them in
# order to find a fallback.
SPACK_PREFERRED_PYTHONS="python3 python /usr/libexec/platform-python "\
"/usr/bin/python3 /usr/bin/python"
PYTHON_CHECK_CMD="import sys, os.path; print(sys.prefix != sys.base_prefix "\
"or os.path.basename(os.path.dirname(sys.prefix)) != '._view')"

for cmd in ${SPACK_PREFERRED_PYTHONS}; do
    if command -v > /dev/null "$cmd"; then
        IS_NOT_FROM_SPACK=`$cmd -c "$PYTHON_CHECK_CMD" 2>/dev/null`
        if test True = "$IS_NOT_FROM_SPACK"; then
            export SPACK_PYTHON=`command -v "$cmd"`
            exec "${SPACK_PYTHON}" "$0" "$@"
        fi
    fi
done
# Try finding fallbacks and trying them if the command 'which' is available.
# Otherwise, we will try the same using whereis.
if command -v which > /dev/null; then
    for base_cmd in ${SPACK_PREFERRED_PYTHONS}; do
        for cmd in `which -a $base_cmd 2>/dev/null`; do
            if command -v > /dev/null "$cmd"; then
                IS_NOT_FROM_SPACK=`$cmd -c "$PYTHON_CHECK_CMD" 2>/dev/null`
                if test True = "$IS_NOT_FROM_SPACK"; then
                    export SPACK_PYTHON=`command -v "$cmd"`
                    exec "${SPACK_PYTHON}" "$0" "$@"
                fi
            fi
        done
    done
elif command -v which > /dev/null; then
    for base_cmd in ${SPACK_PREFERRED_PYTHONS}; do
        for cmd in `whereis $base_cmd 2>/dev/null`; do
            if test "$cmd" != "$base_cmd:" -a -f "$cmd" -a -x "$cmd"; then
                if command -v > /dev/null "$cmd"; then
                    IS_NOT_FROM_SPACK=`$cmd -c "$PYTHON_CHECK_CMD" 2>/dev/null`
                    if test True = "$IS_NOT_FROM_SPACK"; then
                        export SPACK_PYTHON=`command -v "$cmd"`
                        exec "${SPACK_PYTHON}" "$0" "$@"
                    fi
                fi
            fi
        done
    done
fi

echo "==> Error: spack could not find a python interpreter! Adjust your "\
"PATH or set SPACK_PYTHON to a python command/path to set one manually." >&2
exit 1
":"""
# Line above is a shell no-op, and ends a python multi-line comment.
# The code above runs this file with our preferred python interpreter.

import os
import os.path
import sys

min_python3 = (3, 6)

if sys.version_info[:2] < min_python3:
    v_info = sys.version_info[:3]
    msg = "Spack requires Python %d.%d or higher " % min_python3
    msg += "You are running spack with Python %d.%d.%d." % v_info
    sys.exit(msg)

# Find spack's location and its prefix.
spack_file = os.path.realpath(os.path.expanduser(__file__))
spack_prefix = os.path.dirname(os.path.dirname(spack_file))

# Allow spack libs to be imported in our scripts
spack_lib_path = os.path.join(spack_prefix, "lib", "spack")
sys.path.insert(0, spack_lib_path)

from spack_installable.main import main  # noqa: E402

# Once we've set up the system path, run the spack main method
if __name__ == "__main__":
    sys.exit(main())
