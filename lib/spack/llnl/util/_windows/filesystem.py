# Copyright 2013-2022 Lawrence Livermore National Security, LLC and other
# Spack Project Developers. See the top-level COPYRIGHT file for details.
#
# SPDX-License-Identifier: (Apache-2.0 OR MIT)
import ctypes
import errno
import os
import os.path
import shutil
import stat
import warnings
from typing import List, Optional, Union

import win32security

#: Permissions to use on Windows when creating an empty file
EMPTY_FILE_PERMISSIONS = os.O_WRONLY | os.O_CREAT

#: Valid library extensions on Windows
VALID_LIBRARY_EXTENSIONS = [".dll", ".lib"]

#: Common directories where to find libraries
COMMON_LIBRARY_DIRECTORIES = ("lib", "lib64", "bin", "Lib")


def getuid():
    """Return the current process's user id."""
    if ctypes.windll.shell32.IsUserAnAdmin() == 0:
        return 1
    return 0


def rename(src: str, dst: str) -> None:
    # On Windows, os.rename will fail if the destination file already exists
    # Windows path existence checks will sometimes fail on junctions/links/symlinks
    # so check for that case
    if os.path.exists(dst) or os.path.islink(dst):
        os.remove(dst)
    os.rename(src, dst)


def group_ids(uid: Optional[int] = None) -> List[int]:
    """Get group ids that a uid is a member of.

    Arguments:
        uid (int): id of user, or None for current user

    Returns:
        (list of int): gids of groups the user is a member of
    """
    warnings.warn("Function is not supported on Windows")
    return []


def chgrp(path: str, group: Union[str, int], follow_symlinks: bool = True) -> None:
    raise OSError("Function 'chgrp' is not supported on Windows")


def file_command(*args):
    """Creates entry point to `file` system command with provided arguments"""
    raise RuntimeError("`file` utility is not available on Windows")


def _readonly_file_handler(ignore_errors=False):
    # TODO: generate stages etc. with write permissions wherever
    # so this callback is no-longer required
    """
    Generate callback for shutil.rmtree to handle permissions errors on
    Windows. Some files may unexpectedly lack write permissions even
    though they were generated by Spack on behalf of the user (e.g. the
    stage), so this callback will detect such cases and modify the
    permissions if that is the issue. For other errors, the fallback
    is either to raise (if ignore_errors is False) or ignore (if
    ignore_errors is True). This is only intended for Windows systems
    and will raise a separate error if it is ever invoked (by accident)
    on a non-Windows system.
    """

    def error_remove_readonly(func, path, exc):
        excvalue = exc[1]
        if func in (os.rmdir, os.remove, os.unlink) and excvalue.errno == errno.EACCES:
            # change the file to be readable,writable,executable: 0777
            os.chmod(path, stat.S_IRWXU | stat.S_IRWXG | stat.S_IRWXO)
            # retry
            func(path)
        elif not ignore_errors:
            raise

    return error_remove_readonly


def rmtree(*args, **kwargs):
    kwargs["ignore_errors"] = False
    kwargs["onerror"] = _readonly_file_handler(ignore_errors=True)
    return shutil.rmtree(*args, **kwargs)


def is_directory(f: os.DirEntry) -> bool:
    # On Windows, symlinks to directories are distinct from
    # symlinks to files, and it is possible to create a
    # broken symlink to a directory (e.g. using os.symlink
    # without `target_is_directory=True`), invoking `isdir`
    # on a symlink on Windows that is broken in this manner
    # will result in an error. In this case we can work around
    # the issue by reading the target and resolving the
    # directory ourselves
    from ..filesystem import resolve_link_target_relative_to_the_link

    try:
        isdir = f.is_dir()
    except OSError as e:
        if hasattr(e, "winerror") and e.winerror == 5 and f.is_symlink():
            # if path is a symlink, determine destination and
            # evaluate file vs directory
            link_target = resolve_link_target_relative_to_the_link(f)
            # link_target might be relative but
            # resolve_link_target_relative_to_the_link
            # will ensure that if so, that it is relative
            # to the CWD and therefore
            # makes sense
            isdir = os.path.isdir(link_target)
        else:
            raise e
    return isdir


def library_suffixes(*, shared: bool, runtime: bool = True) -> List[str]:
    """Return the library suffixes to be searched on the current platform, based on
    the input parameters.

    Args:
        shared: if True search for shared libraries, if False for static libraries.
        runtime: Windows only option. If true, search for runtime shared libs (.DLL),
            otherwise, search for .Lib files. If shared is false, this has no meaning.
            Defaults to True.
    """
    if shared and runtime:
        # For linking (runtime=False) you need the .lib files regardless of
        # whether you are doing a shared or static link
        return ["dll"]
    return ["lib"]


def uid_for_existing_path(path: str) -> int:
    sid = win32security.GetFileSecurity(
        path, win32security.OWNER_SECURITY_INFORMATION
    ).GetSecurityDescriptorOwner()
    return win32security.LookupAccountSid(None, sid)[0]
