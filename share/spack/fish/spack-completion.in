# Copyright 2013-2022 Lawrence Livermore National Security, LLC and other
# Spack Project Developers. See the top-level COPYRIGHT file for details.
#
# SPDX-License-Identifier: (Apache-2.0 OR MIT)


# NOTE: spack-completion.fish is auto-generated by:
#
#   $ spack commands --aliases --format=fish
#       --header=fish/spack-completion.in --update=spack-completion.fish
#
# Please do not manually modify this file.

# The following global variables are used as cache of `__fish_spack_argparse`

# Cached command line
set -g __fish_spack_argparse_cache_line
# Parsed command
set -g __fish_spack_argparse_command
# Remaining arguments
set -g __fish_spack_argparse_argv
# Return value
set -g __fish_spack_argparse_return

# Spack command generates a optspec variable $__fish_spack_optspecs_<command>
# We find if command exists, and echo the optspec variable name.
function __fish_spack_get_optspecs -d "Get optspecs of spack command"
    # Convert arguments to replace ' ' and '-' by '_'
    set -l cmd_var (string replace -ra -- '[ -]' '_' $argv | string join '_')
    # Set optspec variable name
    set -l optspecs_var __fish_spack_optspecs_$cmd_var
    # Query if variable $$optspecs_var exists
    set -q $optspecs_var; or return 1
    # If it exists, echo all optspecs line by line
    # String join return 1 if no join performed,
    # so we return 0 in such case
    string join \n $$optspecs_var; or return 0
end

# Parse arguments of command line, save results to global variables,
# and all found flags to __flsh_spack_flag_<flag>.
# Returns 1 if help flag is found.
function __fish_spack_argparse
    # Figure out if the current invocation already has a command.
    set -l args $argv
    set -l commands

    # Return cached result if arguments haven't changed
    if test "$__fish_spack_argparse_cache_line" = "$args"
        return $__fish_spack_argparse_return
    end

    # Clear all found flags in last run
    set -g | string replace -rf -- '^(__fish_spack_flag_\w+)(.*?)$' 'set -ge $1' | source

    # Set default return value to 0, indicating success
    set -g __fish_spack_argparse_return 0
    # Set command line to current arguments
    set -g __fish_spack_argparse_cache_line $argv

    # Recursively check arguments for commands
    while set -q args[1]
        # Get optspecs of current command
        set -l optspecs (__fish_spack_get_optspecs $commands $args[1])
        or break

        # If command exists, shift arguments
        set -a commands $args[1]
        set -e args[1]

        # If command has no arguments, continue
        set -q optspecs[1]; or continue

        # Parse arguments. argparse set variable _flag_<flag> if flag is found
        # we find all these variables and 
        # set them to global variable __fish_spack_flag_<flag>
        argparse -i -s $optspecs -- $args 2>/dev/null; or break
        set -l | string replace -rf -- '^(_flag_.*)$' 'set -g __fish_spack$1' | source

        # Set args to not parsed arguments
        set args $argv

        # If command has help flag, we don't need to 
        # parse more so short circuit
        if set -q _flag_help
            set -g __fish_spack_argparse_return 1
            break
        end
    end

    # Set cached variables
    set -g __fish_spack_argparse_command $commands
    set -g __fish_spack_argparse_argv $args

    return $__fish_spack_argparse_return
end

# Check if current commandline's command is "spack $argv"
function __fish_spack_using_command
    set -l line (commandline -opc)
    __fish_spack_argparse $line; or return 1

    set -p argv spack
    test "$__fish_spack_argparse_command" = "$argv"
end

# Check if current commandline's command is "spack $argv[2..-1]",
# and cursor is at $argv[1]-th positional argument
function __fish_spack_using_command_pos
    __fish_spack_using_command $argv[2..-1]
    or return

    test (count $__fish_spack_argparse_argv) = $argv[1]
end

# Spack commands
#
# Everything below here is auto-generated.

function __fish_spack_bootstrap_names
    if set -q __fish_spack_flag_scope
        spack bootstrap list --scope $__fish_spack_flag_scope | string replace -rf -- '^Name: (\w+).*?$' '$1'
    else
        spack bootstrap list | string replace -rf -- '^Name: (\w+).*?$' '$1'
    end
end

# Reference: sudo's fish completion
function __fish_spack_build_env_spec
    set token (commandline -opt)

    set -l index (contains -- -- $__fish_spack_argparse_argv)
    if set -q index[1]
        __fish_complete_subcommand --commandline $__fish_spack_argparse_argv[(math $index + 1)..-1]
    else if set -q __fish_spack_argparse_argv[1]
        __fish_complete_subcommand --commandline "$__fish_spack_argparse_argv[2..-1] $token"
    else
        __fish_spack_specs
    end
end

function __fish_spack_commands
    spack commands
end

function __fish_spack_colon_path
    set token (commandline -opt | string split -rm1 ':')

    if test (count $token) -lt 2
        __fish_complete_path $token[1]
    else
        __fish_complete_path $token[2] | string replace -r -- '^' "$token[1]:"
    end
end

function __fish_spack_config_sections
    if set -q __fish_spack_flag_scope
        spack config --scope $__fish_spack_flag_scope list | string split ' '
    else
        spack config list | string split ' '
    end
end

function __fish_spack_environments
    string trim (spack env list)
end

function __fish_spack_extensions
    string trim (spack extensions)
end

function __fish_spack_gpg_keys
    spack gpg list
end

function __fish_spack_installed_compilers
    spack compilers | grep -v '^[=-]\|^$'
end

function __fish_spack_installed_packages
    spack find --no-groups --format "{name}" | uniq
end

function __fish_spack_installed_specs
    # Try match local hash first
    __fish_spack_installed_specs_id
    and return

    spack find --no-groups --format "{name}@{version}"
end

function __fish_spack_installed_specs_id
    set -l token (commandline -opt)
    string match -q -- '/*' $token
    or return 1

    spack find --format '/{hash:7}'\t'{name}{@version}'
end

function __fish_spack_git_rev
    type -q __fish_git_ranges
    and __fish_git_ranges
end

function __fish_spack_mirrors
    spack mirror list | awk {'printf ("%s\t%s", $1, $2)'}
end

function __fish_spack_package_versions
    string trim (spack versions $argv)
end

function __fish_spack_packages
    spack list
end

function __fish_spack_pkg_packages
    spack pkg list
end

function __fish_spack_providers
    string trim (spack providers | grep -v '^$')
end

function __fish_spack_repos
    spack repo list | awk {'printf ("%s\t%s", $1, $2)'}
end

function __fish_spack_scopes
    # TODO: how to list all scopes?
    set -l scope system site user defaults
    set -l platform cray darwin linux test

    string join \n $scope
end

function __fish_spack_specs
    set -l token (commandline -opt)

    # Complete compilers
    if string match -rq -- '^(?<pre>.*%)[\w-]*(@[\w\.]*)?$' $token
        __fish_spack_installed_compilers | sed "s#^#$pre#"
        return
    end

    # Try to complete spec version
    # Currently we can only match '@' after a package name
    set -l package

    # Match @ following package name
    if string match -rq -- '\^?(?<pre>[\w+~-]*)@[\w\.]*$' $token
        set package $pre

        # Matched @ starting at next token
        if test -z "$package"
            string match -arq -- '(^|\^)(?<inner>[\w+~-]*)$' $__fish_spack_argparse_argv[-1]
            if set -q inner[1]
                set package $inner[-1]
            end
        end
    end

    # Complete version if package found
    if test -n "$package"
        # Only list safe versions for speed
        string trim (spack versions --safe $package) | sed "s#^#$pre@#"
        return
    end

    # Else complete package name
    __fish_spack_installed_packages | sed "s#\$#\tinstalled#"
    spack list
end

function __fish_spack_specs_or_id
    # Try match local hash first
    __fish_spack_installed_specs_id
    and return

    __fish_spack_specs
end

function __fish_spack_tags
    string trim (spack tags)
end

function __fish_spack_tests
    spack test list | grep -v '^[=-]'
end

function __fish_spack_unit_tests
    spack unit-test -l
end

function __fish_spack_yamls
    # Trim flag from current token
    string match -rq -- '(?<pre>-.)?(?<token>.*)' (commandline -opt)

    if test -n "$token"
        find $token* -type f '(' -iname '*.yaml' -or -iname '*.yml' ')'
    else
        find -maxdepth 2 -type f '(' -iname '*.yaml' -or -iname '*.yml' ')' | cut -c 3-
    end
end

complete -c spack --erase
